package io.github.mianalysis.mia.thirdparty;

import java.awt.Color;
import java.awt.Font;
import java.awt.Point;
import java.awt.image.IndexColorModel;

import ij.IJ;
import ij.ImagePlus;
import ij.ImageStack;
import ij.WindowManager;
import ij.gui.GenericDialog;
import ij.gui.ImageCanvas;
import ij.gui.ImageWindow;
import ij.gui.NewImage;
import ij.plugin.PlugIn;
import ij.process.ImageProcessor;

public class Colour_Deconvolution2 implements PlugIn {

// Colour_Deconvolution2.java Copyright (C) 2020 Gabriel Landini, 
// G. Landini at bham ac uk
//
// License:
// Colour Deconvolution2 plugin. Copyright (C) 2004-2020 Gabriel Landini. 
// This program is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software
// Foundation, either version 3 of the License, or (at your option) any later version.
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details. You should have received a copy of
// the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/
//
// This ImageJ plugin implements stain separation using the colour deconvolution method described in:
//
//     Ruifrok AC, Johnston DA. Quantification of histochemical
//     staining by color deconvolution. Analytical & Quantitative
//     Cytology & Histology 2001; 23: 291-299.
//
// The code is based on "Color separation-30", a macro for NIH Image kindly provided
// by A.C. Ruifrok. Thanks Arnout!
//
// The plugin assumes images generated by color subtraction (i.e. light-absorbing dyes
// such as those used in bright field histology or ink on printed paper) but the dyes
// should not be neutral grey.
//
// Please read the paper reference above to understand how to determine
// new vectors and how the whole procedure works.
//
// The plugin expects the background is neutral (white to light grey), therefore background
// subtraction and colour correction *must* be applied to the images before processing.
// Neutral colours (greys) cannot be separated successfully with this method.
//
// The plugin provides a number of "built in" stain vectors some of which were determined
// experimentally in our lab (marked GL), but you are strongly adviced to determine your
// own vectors to achieve accurate stain separation.
// Using the built-in vectors blindly is NOT a good idea.
//
// Ideally, vector determination should be done on slides stained with only one colour at
// a time (using the "From ROI" interactive option).
//
// The plugin takes an RGB image as input and returns three 8-bit, 32bit or 24bit images.
// If the specimen is stained with a 2 colour scheme (such as H & E) the 3rd image component
// can be determined by two differen methods. That image represents the residual of stain
// separation process.
//
// Caution must be exercised to avoid overinterpreting the results of colour deconvolution.
// Most staining methods are NOT stochiometric and so the optical density of the dye may
// not correlate well with the *quantity* of reactants.
// This means that optical density of the colour may not be a good indicator of the amount
// of material stained.
// While tempting, please do NOT use this plugin to quantify "expression" of immunostained
// (IHC) sections for the reasons given above.
//
// Read the paper!
//
// This software is released under GPL v3 license, you can find a 
// copy of this license at http://www.gnu.org/copyleft/gpl.html
//
// Version history
// ---------------
// 30/Mar/2004 1.0   Released.
// 03/Apr/2004       Resolved ROI exiting.
// 07/Apr/2004       Added Methyl Green DAB vectors.
// 08/Jul/2004 1.1   Shortened the code.
// 01/Aug/2005       Added fast red/blue/DAB vectors.
// 02/Nov/2005 1.2   Changed code to work with image stacks (thanks to DLC - dchao at fhcrc org).
//                   Changed field names so user-defined colours can be set within macros
//                   (thanks to DLC - dchao at fhcrc org)
// 04/Feb/2007 1.3   Disable popup menu when right clicking.
// 23/May/2009       Added Feulgen-light green vectors.
// 14/Apr/2010 1.4   Added Giemsa vector (Methylene blue & eosin) .
//                   Images are named "title"-(Colour_1) etc. to avoid clashes when using [ ]
//                   The log window now prints the java code of the translation matrix to include
//                   new vectors in the plugin.
//                   Added "Hide legend" option.
// 22/Jun/2010 1.5   Added Masson Trichrome vector (Methyl blue & Ponceau Fuchsin only (so it does
//                   not include a Iron Haematoxylin vector!).
//                   Fixed bug: check for 0 components before hiding legend (no image was shown if
//                   the legend was hidden).
// 26/Mar/2011 1.6   Added Brilliant_Blue stain for dental plaque detection.
// 03/Aug/2011 1.7   Added progress bar (thanks to Oskari Jaaskelainen).
//                   Added warning about immunostain quantification.
// 30/Sep/2011 1.8   Added H, DAB, New Fuchsin triple labelling.
// 14/Oct/2011 1.9   Added H, Green HRP, New Fuchsin triple labelling.
// 23/Sep/2013 1.10  Fixed Feulgen's stain name typo.
// 26/Sep/2014 1.11  Added Astra Blue, Fuchsin.
// 01/Jun/2016 1.12  Added NBT/BCIP Red Counterstain II.
// 04/Jun/2020 1.13  Thanks to Filippo Piccinini tidied up transmittance and cosx/y/z values.
// 21/Jun/2020 2.0   * Added option for determining the 3rd undefined colour the cross product of the
//                   two other vectors). This is the ideal way to determine it, yet the old method remains
//                   available (just untick the 'Cross product' option) for back-compatibility and 
//                   historical reasons.
//                   Using the cross product for determining the 3rd colour can result in matrices
//                   with negative coeficients (i.e. 'impossible' colours), and therefore the LUT
//                   of the 3rd component determined this way will not represent a given colour in
//                   the image. Thanks to communications by Gloria Diaz, Mitko Veta and Peter Haub.
//                   * Added options to output LUTs images, 32bit images (transmittance, absorbance)
//                   and RGB (i.e. intensity) images. RGB output includes operations to remove or
//                   keep a particular colour. The same warning above remains for automatically
//                   determined 3rd vectors. Thanks to Filippo Piccinini for his help and testing.
//                   * Added an "RGB Retain all" option which is useful to understand how image
//                   colour data are processed by the colour deconvolution (e.g. dyes lacking "ideal"
//                   behaviour in terms of Beer-Lambert law).
//                   * Speeded up code > 3.2 times (Java 14) (thanks to Pete Bankhead and Peter Haub
//                   for their useful comments on precomputing some formulae).
//                   * The code now checks whether the matrix can be inverted (non-zero determinant).
//                   If not, the program will attempt to make it invertible by adding a small value
//                   (0.001) to the rows, columns or diagonals that add to 0.  A warning is shown
//                   if "Show matrices" is checked. This is a bit less drastic than the original code
//                   which added those small value to all 0 matrix coefficients. Be aware of any
//                   warnings when determining new vectors to be sure that the LUTs represent intended
//                   colours.
//                   * The option to show matrix values is overridden and set to true when the input
//                   is via ROIs or User Values (you want to know what the results were).
//                   * The plugin now has a public exec() method that can be called directly without
//                   showing any images. The exec() method expects the *Input Vector Matrix* values.
//                   * An autogenerated macro is printed to the log window when one determines vectors
//                   from ROIs (it saves typing lots of numbers).
//                   * Added warning about determining your own vectors.
//                   * The Legend now shows the Computed Vector Matrix which defines the colours shown
//                   (instead of the Input Vector Matrix which needs to be normalised, etc.).
//                   * Fixed ROIs numbering, fixed legend colour for cross product setting.
// 05/Oct/2020 2.0   * Fixed typos in the comments, added version number to the panel.
// 28/Apr/2022 2.0   * Clarified some comments on the cross-product.
// 05/Aug/2022 2.1   * Added paper reference to help button in the dialog.
//                   * Added output for the Inverted Vector Matrix q.
//                   * Output images now preserve spatial calibration (suggested by Jacqueline Ross).


	public void run(String arg) {

		// 1 - Obtain the active image
		ImagePlus imp = WindowManager.getCurrentImage();
		if (imp == null) {
			IJ.error("No image!");
			return;
		}
		if (imp.getBitDepth() != 24) {
			IJ.error("RGB image needed.");
			return;
		}

		String title = imp.getTitle();
		Font font = new Font("SansSerif", Font.BOLD, 12);

		// 2 - Ask for parameters
		GenericDialog gd = new GenericDialog("Colour Deconvolution 2", IJ.getInstance());
		gd.addMessage("Colour Deconvolution2 v2.1");
		gd.addMessage("Warning: This plugin is not suitable to quantify\nthe intensity of immunostained slides because\nimmunostains are not stoichiometric.",font );
		gd.addMessage("Please consider determining your own vectors.\nThose provided here may not match the colours\nin your slides.");
		
		String [] stain={"From ROI","H&E", "H&E 2","H DAB", "H&E DAB", "NBT/BCIP Red Counterstain II", "H DAB NewFuchsin", "H HRP-Green NewFuchsin", "Feulgen LightGreen", "Giemsa", "FastRed FastBlue DAB", "Methyl Green DAB",  "H AEC","Azan-Mallory","Masson Trichrome","Alcian Blue & H","H PAS","Brilliant Blue","AstraBlue Fuchsin", "RGB","CMY", "User values"};
		gd.addChoice("Vectors", stain, stain[0]);
		String [] outputs={"8bit_Transmittance", "32bit_Transmittance","32bit_Absorbance", "RGB_Remove_C1", "RGB_Remove_C2", "RGB_Remove_C3", "RGB_Keep_C1", "RGB_Keep_C2", "RGB_Keep_C3", "RGB_Retain_all"};
		gd.addChoice("Output", outputs, outputs[0]);
		gd.addCheckbox("Simulated LUTs",true);
		gd.addCheckbox("Cross product for Colour_3",true);
		gd.addCheckbox("Show matrices",false);
		gd.addCheckbox("Hide legend",true);
		gd.addHelp("https://doi.org/10.1093/bioinformatics/btaa847");

		gd.showDialog();
		if (gd.wasCanceled())
			return;

		// 3 - Retrieve parameters from the dialog
		String myStain = gd.getNextChoice();
		String myOutput = gd.getNextChoice();
		boolean doILUTs = gd.getNextBoolean();
		boolean doIcross = gd.getNextBoolean();
		boolean doIshow = gd.getNextBoolean();
		boolean hideLegend = gd.getNextBoolean();

		double [] MODx = new double[3];
		double [] MODy = new double[3];
		double [] MODz = new double[3];

		if (myOutput.equals("32bit_Absorbance")) doILUTs = false; //override LUTs


		// Stains are defined after this line ------------------------
		if (myStain.equals("H&E")) {
			// GL Haem matrix
			MODx[0] = 0.644211; MODy[0] = 0.716556; MODz[0] = 0.266844;
			// GL Eos matrix
			MODx[1] = 0.092789; MODy[1] = 0.954111; MODz[1] = 0.283111;
			// Zero matrix
			MODx[2] = 0.0; MODy[2] = 0.0; MODz[2] = 0.0;
		}

		if (myStain.equals("H&E 2")) {
			// GL Haem matrix
			MODx[0] = 0.49015734; MODy[0] = 0.76897085; MODz[0] = 0.41040173;
			// GL Eos matrix
			MODx[1] = 0.04615336; MODy[1] = 0.8420684; MODz[1] = 0.5373925;
			// Zero matrix
			MODx[2] = 0.0; MODy[2] = 0.0; MODz[2] = 0.0;
		}

		if (myStain.equals("H DAB")) {
			// Haem matrix
			MODx[0] = 0.650; MODy[0] = 0.704; MODz[0] = 0.286;
			// DAB matrix  3,3-diamino-benzidine tetrahydrochloride
			MODx[1] = 0.268; MODy[1] = 0.570; MODz[1] = 0.776;
			// Zero matrix
			MODx[2] = 0.0; MODy[2] = 0.0; MODz[2] = 0.0;
		}

		if (myStain.equals("NBT/BCIP Red Counterstain II")) {
			// Used in HR-HPV ISH (INFORM HPV III, Roche Ventana)
			// NBT.BCIP
			MODx[0] = 0.62302786; MODy[0] = 0.697869; MODz[0] = 0.3532918;
			// Red Counterstain II
			MODx[1] = 0.073615186; MODy[1] = 0.79345673; MODz[1] = 0.6041582;
			// Zero matrix
			MODx[2] = 0.0; MODy[2] = 0.0; MODz[2] = 0.0;
		}

		if (myStain.equals("H DAB NewFuchsin")) {
			// mutilple immunostains labelling from J Isola's lab
			// Haematoxylin
			MODx[0] = 0.5625407925; MODy[0] = 0.70450559; MODz[0] = 0.4308375625;
			// DAB
			MODx[1] = 0.26503363; MODy[1] = 0.68898016; MODz[1] = 0.674584;
			// NewFuchsin
			MODx[2] = 0.0777851125; MODy[2] = 0.804293475; MODz[2] = 0.5886050475;
		}

		if (myStain.equals("H HRP-Green NewFuchsin")) {
			// mutilple immunostains labelling from J Isola's lab
			// HRP-Green
			MODx[0] = 0.8098939567; MODy[0] = 0.4488181033; MODz[0] = 0.3714423567;
			// NewFuchsin
			MODx[1] = 0.0777851125; MODy[1] = 0.804293475; MODz[1] = 0.5886050475;
			// Zero matrix
			MODx[2] = 0; MODy[2] = 0; MODz[2] = 0;
		}

		if (myStain.equals("Feulgen LightGreen")) {
			// Feulgen
			MODx[0] = 0.46420921; MODy[0] = 0.83008335; MODz[0] = 0.30827187;
			// Light Green
			MODx[1] = 0.94705542; MODy[1] = 0.25373821; MODz[1] = 0.19650764;
			// Zero matrix
			MODx[2] = 0.0; MODy[2] = 0.0; MODz[2] = 0.0;
		}

		if (myStain.equals("Giemsa")) {
			// GL Methylene Blue
			MODx[0] = 0.834750233; MODy[0] = 0.513556283; MODz[0] = 0.196330403;
			// GL Eosin matrix
			MODx[1] = 0.092789; MODy[1] = 0.954111; MODz[1] = 0.283111;
			// Zero matrix
			MODx[2] = 0.0; MODy[2] = 0.0; MODz[2] = 0.0;
		}

		if (myStain.equals("FastRed FastBlue DAB")) {
			// GL Fast red
			MODx[0] = 0.21393921; MODy[0] = 0.85112669; MODz[0] = 0.47794022;
			// GL Fast blue
			MODx[1] = 0.74890292; MODy[1] = 0.60624161; MODz[1] = 0.26731082;
			// DAB
			MODx[2] = 0.268; MODy[2] = 0.570; MODz[2] = 0.776;
		}

		if (myStain.equals("Methyl Green DAB")) {
			// GL Methyl Green matrix
			MODx[0] = 0.98003; MODy[0] = 0.144316; MODz[0] = 0.133146;
			// DAB matrix
			MODx[1] = 0.268; MODy[1] = 0.570; MODz[1] = 0.776;
			// Zero matrix
			MODx[2] = 0.0; MODy[2] = 0.0; MODz[2] = 0.0;
		}

		if (myStain.equals("H&E DAB")) {
			// Haematoxylin matrix
			MODx[0] = 0.650; MODy[0] = 0.704; MODz[0] = 0.286;
			// Eosin matrix
			MODx[1] = 0.072; MODy[1] = 0.990; MODz[1] = 0.105;
			// DAB matrix
			MODx[2] = 0.268; MODy[2] = 0.570; MODz[2] = 0.776;
		}

		if (myStain.equals("H AEC")) {
			// Haematoxylin matrix
			MODx[0] = 0.650; MODy[0] = 0.704; MODz[0] = 0.286;
			// AEC 3-amino-9-ethylcarbazole
			MODx[1] = 0.2743; MODy[1] = 0.6796; MODz[1] = 0.6803;
			// Zero matrix
			MODx[2] = 0.0; MODy[2] = 0.0; MODz[2] = 0.0;
		}

		if (myStain.equals("Azan-Mallory")) {
			// Azocarmine and Aniline Blue (AZAN)
			// GL Aniline Blue
			MODx[0] = 0.853033; MODy[0] = 0.508733; MODz[0] = 0.112656;
			// GL Azocarmine
			MODx[1] = 0.09289875; MODy[1] = 0.8662008; MODz[1] = 0.49098468;
			// GL Orange-G
			MODx[2] = 0.10732849; MODy[2] = 0.36765403; MODz[2] = 0.9237484;
		}

		if (myStain.equals("Masson Trichrome")) {
			// GL Methyl blue
			MODx[0] = 0.7995107; MODy[0] = 0.5913521; MODz[0] = 0.10528667;
			// GL Ponceau-Fuchsin has 2 hues, really this is only approximate
			MODx[1] = 0.09997159; MODy[1] = 0.73738605; MODz[1] = 0.6680326;
			// Zero matrix
			MODx[2] = 0.0; MODy[2] = 0.0; MODz[2] = 0.0;
			// GL Iron Haematoxylin, but this does not seem to work well because it gets confused with the other 2 components
			// MODx[2]=0.6588232; MODy[2]=0.66414213; MODz[2]=0.3533655;
		}

		if (myStain.equals("Alcian Blue & H")) {
			// GL Alcian Blue matrix
			MODx[0] = 0.874622; MODy[0] = 0.457711; MODz[0] = 0.158256;
			// GL Haematox after PAS matrix
			MODx[1] = 0.552556; MODy[1] = 0.7544; MODz[1] = 0.353744;
			// Zero matrix
			MODx[2] = 0.0; MODy[2] = 0.0; MODz[2] = 0.0;
		}

		if (myStain.equals("H PAS")) {
			// GL Haem matrix
			MODx[0] = 0.644211; MODy[0] = 0.716556; MODz[0] = 0.266844;
			// GL PAS matrix
			MODx[1] = 0.175411; MODy[1] = 0.972178; MODz[1] = 0.154589;
			// Zero matrix
			MODx[2] = 0.0; MODy[2] = 0.0; MODz[2] = 0.0;
		}

		if (myStain.equals("Brilliant Blue")) {
			MODx[0] = 0.31465548; MODy[0] = 0.6602395; MODz[0] = 0.68196464;

			MODx[1] = 0.383573; MODy[1] = 0.5271141; MODz[1] = 0.7583024;

			MODx[2] = 0.7433543; MODy[2] = 0.51731443; MODz[2] = 0.4240403;
		}

		if (myStain.equals("AstraBlue Fuchsin")) {
			// GL AstraBlue
			MODx[0] = 0.92045766; MODy[0] = 0.35425216; MODz[0] = 0.16511545;
			// GL Basic Fuchsin
			MODx[1] = 0.13336428; MODy[1] = 0.8301452; MODz[1] = 0.5413621;
			// Zero matrix
			MODx[2] = 0.0; MODy[2] = 0.0; MODz[2] = 0.0;
		}

		if (myStain.equals("RGB")) {
			//R
			MODx[0] = 0.001; MODy[0] = 1.0; MODz[0] = 1.0;
			//G
			MODx[1] = 1.0; MODy[1] = 0.001; MODz[1] = 1.0;
			//B
			MODx[2] = 1.0; MODy[2] = 1.0; MODz[2] = 0.001;
		}

		if (myStain.equals("CMY")) {
			//C
			MODx[0] = 1.0; MODy[0] = 0.0; MODz[0] = 0.0;
			//M
			MODx[1] = 0.0; MODy[1] = 1.0; MODz[1] = 0.0;
			//Y
			MODx[2] = 0.0; MODy[2] = 0.0; MODz[2] = 1.0;
		}

		if (myStain.equals("User values")) {
			// Get the Input Vector Matrix
			GenericDialog gd2 = new GenericDialog("User values", IJ.getInstance());
			gd2.addMessage("Colour[1]", font);
			gd2.addNumericField("[R1]", 0, 5);
			gd2.addNumericField("[G1]", 0, 5);
			gd2.addNumericField("[B1]", 0, 5);
			gd2.addMessage("Colour[2]", font);
			gd2.addNumericField("[R2]", 0, 5);
			gd2.addNumericField("[G2]", 0, 5);
			gd2.addNumericField("[B2]", 0, 5);
			gd2.addMessage("Colour[3]", font);
			gd2.addNumericField("[R3]", 0, 5);
			gd2.addNumericField("[G3]", 0, 5);
			gd2.addNumericField("[B3]", 0, 5);
			gd2.showDialog();
			if (gd2.wasCanceled())
				return;

			MODx[0]= gd2.getNextNumber();
			MODy[0]= gd2.getNextNumber();
			MODz[0]= gd2.getNextNumber();

			MODx[1]= gd2.getNextNumber();
			MODy[1]= gd2.getNextNumber();
			MODz[1]= gd2.getNextNumber();

			MODx[2]= gd2.getNextNumber();
			MODy[2]= gd2.getNextNumber();
			MODz[2]= gd2.getNextNumber();
			doIshow = true; //override to show values
		}

		if (myStain.equals("From ROI")) {
			imp.getCanvas().disablePopupMenu(true);
			double [] rgbOD = new double[3];
			double [] len = new double[3];
			int i;

			for (i=0; i<3; i++) {
				getmeanRGBODfromROI(i, rgbOD, imp);
				MODx[i]= rgbOD[0];
				MODy[i]= rgbOD[1];
				MODz[i]= rgbOD[2];
			}

			for (i=0; i<3; i++) {
				//normalise vector length
				len[i]=Math.sqrt(MODx[i]*MODx[i] + MODy[i]*MODy[i] + MODz[i]*MODz[i]);
				if (len[i] != 0.0) {
					MODx[i]= MODx[i]/len[i];
					MODy[i]= MODy[i]/len[i];
					MODz[i]= MODz[i]/len[i];
				}
			}

			imp.getCanvas().disablePopupMenu(false);
			doIshow = true; //override to show newly determined values
		}

		// 4 - Execute
		Object[] result = exec(imp, title, myStain, myOutput, doILUTs, doIcross, doIshow, hideLegend, MODx, MODy, MODz);

		// 5 - Show the result images
		if (null != result) {
			if (!hideLegend) {
				ImagePlus resultImage0 = (ImagePlus) result[0]; //the legend image
				resultImage0.show();
			}

			if (myOutput.equals("8bit_Transmittance") || myOutput.equals("32bit_Transmittance") || myOutput.equals("32bit_Absorbance")) {

				ImagePlus resultImage1 = (ImagePlus) result[1]; //channel 1
				ImagePlus resultImage2 = (ImagePlus) result[2]; //channel 2
				ImagePlus resultImage3 = (ImagePlus) result[3]; //channel 3
				resultImage1.setCalibration(imp.getCalibration());
				resultImage2.setCalibration(imp.getCalibration());
				resultImage3.setCalibration(imp.getCalibration());

				if (myOutput.equals("32bit_Transmittance")) {
					resultImage1.setDisplayRange(0, 1);
					resultImage2.setDisplayRange(0, 1);
					resultImage3.setDisplayRange(0, 1);
				}
				if (myOutput.equals("32bit_Absorbance")) {
					resultImage1.setDisplayRange(0, 2.41);
					resultImage2.setDisplayRange(0, 2.41);
					resultImage3.setDisplayRange(0, 2.41);
				}

				resultImage1.show();
				resultImage2.show();
				resultImage3.show();
			}
			else {
				ImagePlus resultImage1 = (ImagePlus) result[1];
				resultImage1.setCalibration(imp.getCalibration());
				resultImage1.show();
			}
		}
	}


	public Object[] exec(ImagePlus imp, String title, String myStain, String myOutput, boolean doILUTs , boolean doIcross, boolean doIshow, boolean hideLegend, double [] MODx, double [] MODy, double [] MODz) {

		double A, V, C;
		int i, j, width = imp.getWidth(), height = imp.getHeight();
		double leng;
		double [] cosx = new double[3];
		double [] cosy = new double[3];
		double [] cosz  = new double[3];
		double [] len = new double[3];
		double [] q = new double[9];
		byte [] rLUT = new byte[256];
		byte [] gLUT = new byte[256];
		byte [] bLUT = new byte[256];
		int [] ColourLUT = new int[3];
		boolean twoDyes = false;
		String suffix = "";

		ImageStack stack = imp.getStack();
		IJ.showStatus("Colour Deconvolution...");

		// Compute Vector Matrix
		// normalise vectors lengths
		for (i = 0; i < 3; i++) {
			cosx[i] = cosy[i] = cosz[i] = 0.0;
			len[i] = Math.sqrt(MODx[i] * MODx[i] + MODy[i] * MODy[i] + MODz[i] * MODz[i]);
			if (len[i] != 0.0) {
				cosx[i] = MODx[i] / len[i];
				cosy[i] = MODy[i] / len[i];
				cosz[i] = MODz[i] / len[i];
			}
		}

		// Check channels 2 and 3
		if (cosx[1] == 0.0) {
			if (cosy[1] == 0.0) {
				if (cosz[1] == 0.0) {
					//2nd colour is unspecified
					cosx[1] = cosz[0];
					cosy[1] = cosx[0];
					cosz[1] = cosy[0];
				}
			}
		}

		if (cosx[2] == 0.0) {
			if (cosy[2] == 0.0) {
				if (cosz[2] == 0.0) {
					// 3rd colour is unspecified
					twoDyes = true;
					if (doIcross) {
						// cross prduct for 3rd vector
						cosx[2] = cosy[0] * cosz[1] - cosz[0] * cosy[1];
						cosy[2] = cosz[0] * cosx[1] - cosx[0] * cosz[1];
						cosz[2] = cosx[0] * cosy[1] - cosy[0] * cosx[1];
					}
					else {
						// Ruifrok & Johnston's method for complementary colour
						if ((cosx[0] * cosx[0] + cosx[1] * cosx[1]) > 1) {
							if (doIshow)
								IJ.log("Colour_3 has a negative R component.");
							cosx[2] = 0.0;
						}
						else {
							cosx[2] = Math.sqrt(1.0 - (cosx[0] * cosx[0]) - (cosx[1] * cosx[1]));
						}

						if ((cosy[0] * cosy[0] + cosy[1] * cosy[1]) > 1) {
							if (doIshow)
								IJ.log("Colour_3 has a negative G component.");
							cosy[2] = 0.0;
						}
						else {
							cosy[2] = Math.sqrt(1.0 - (cosy[0] * cosy[0]) - (cosy[1] * cosy[1]));
						}

						if ((cosz[0] * cosz[0] + cosz[1] * cosz[1]) > 1) {
							if (doIshow)
								IJ.log("Colour_3 has a negative B component.");
							cosz[2] = 0.0;
						}
						else {
							cosz[2] = Math.sqrt(1.0 - (cosz[0] * cosz[0]) - (cosz[1] * cosz[1]));
						}
					}
				}
			}
		}

		leng = Math.sqrt(cosx[2] * cosx[2] + cosy[2] * cosy[2] + cosz[2] * cosz[2]);

		if (leng != 0.0) {
			cosx[2] = cosx[2] / leng;
			cosy[2] = cosy[2] / leng;
			cosz[2] = cosz[2] / leng;
		}

		// Handle matrices with a 0 determinant (Ruifrok & Jonhston added 0.001 to all 0 entries)
		double[][] COSmat = {
			{ cosx[0], cosy[0], cosz[0] },
			{ cosx[1], cosy[1], cosz[1] },
			{ cosx[2], cosy[2], cosz[2] }
		};

		double detCOS, detCOSa, detCOSb, detCOSc;
		detCOSa = COSmat[0][0] * ((COSmat[1][1] * COSmat[2][2]) - (COSmat[1][2] * COSmat[2][1]));
		detCOSb = COSmat[0][1] * ((COSmat[1][0] * COSmat[2][2]) - (COSmat[1][2] * COSmat[2][0]));
		detCOSc = COSmat[0][2] * ((COSmat[1][0] * COSmat[2][1]) - (COSmat[1][1] * COSmat[2][0]));
		detCOS  = detCOSa - detCOSb + detCOSc;

		if (doIshow) IJ.log("\nMatrix determinant: " + detCOS);
		if (detCOS >= -0.001 && detCOS <= 0.001) {
			// Check column 0
			if (COSmat[0][0] + COSmat[1][0] + COSmat[2][0] == 0.0) {
				cosx[0] = 0.001;
				cosx[1] = 0.001;
				cosx[2] = 0.001;
			}
			// Check column 1
			if (COSmat[0][1] + COSmat[1][1] + COSmat[2][1] == 0.0) {
				cosy[0] = 0.001;
				cosy[1] = 0.001;
				cosy[2] = 0.001;
			}
			// Check column 2
			if (COSmat[0][2] + COSmat[1][2] + COSmat[2][2] == 0.0) {
				cosz[0] = 0.001;
				cosz[1] = 0.001;
				cosz[2] = 0.001;
			}
			// Check row 0
			if (COSmat[0][0] + COSmat[0][1] + COSmat[0][2] == 0.0) {
				cosx[0] = 0.001;
				cosy[0] = 0.001;
				cosz[0] = 0.001;
			}
			// Check row 1
			if (COSmat[1][0] + COSmat[1][1] + COSmat[1][2] == 0.0) {
				cosx[1] = 0.001;
				cosy[1] = 0.001;
				cosz[1] = 0.001;
			}
			// Check row 2
			if (COSmat[2][0] + COSmat[2][1] + COSmat[2][2] == 0.0) {
				cosx[2] = 0.001;
				cosy[2] = 0.001;
				cosz[2] = 0.001;
			}
			// Check diagonal 1
			if (COSmat[0][0] + COSmat[1][1] + COSmat[2][2] == 0.0) {
				cosx[0] = 0.001;
				cosy[1] = 0.001;
				cosz[2] = 0.001;
			}
			// Check diagonal 2
			if (COSmat[0][2] + COSmat[1][1] + COSmat[2][0] == 0.0) {
				cosx[2] = 0.001;
				cosy[1] = 0.001;
				cosz[0] = 0.001;
			}
			// Check again the determinant
			COSmat[0][0] = cosx[0]; COSmat[0][1] = cosy[0]; COSmat[0][2] = cosz[0];
			COSmat[1][0] = cosx[1]; COSmat[1][1] = cosy[1]; COSmat[1][2] = cosz[1];
			COSmat[2][0] = cosx[2]; COSmat[2][1] = cosy[2]; COSmat[2][2] = cosz[2];

			detCOSa = COSmat[0][0] * ((COSmat[1][1] * COSmat[2][2]) - (COSmat[1][2] * COSmat[2][1]));
			detCOSb = COSmat[0][1] * ((COSmat[1][0] * COSmat[2][2]) - (COSmat[1][2] * COSmat[2][0]));
			detCOSc = COSmat[0][2] * ((COSmat[1][0] * COSmat[2][1]) - (COSmat[1][1] * COSmat[2][0]));
			detCOS  = detCOSa - detCOSb + detCOSc;

			if (doIshow) IJ.log("Matrix determinant: " + detCOS + " (first attempt)");

			if (detCOS >= -0.001 && detCOS <= 0.001) {
				for (int h = 0; h < 3; h++) {
					if (cosx[h] == 0.0) cosx[h] = 0.001;
					if (cosy[h] == 0.0) cosy[h] = 0.001;
					if (cosz[h] == 0.0) cosz[h] = 0.001;
				}
				// Check again the determinant
				COSmat[0][0] = cosx[0]; COSmat[0][1] = cosy[0]; COSmat[0][2] = cosz[0];
				COSmat[1][0] = cosx[1]; COSmat[1][1] = cosy[1]; COSmat[1][2] = cosz[1];
				COSmat[2][0] = cosx[2]; COSmat[2][1] = cosy[2]; COSmat[2][2] = cosz[2];

				detCOSa = COSmat[0][0] * ((COSmat[1][1] * COSmat[2][2]) - (COSmat[1][2] * COSmat[2][1]));
				detCOSb = COSmat[0][1] * ((COSmat[1][0] * COSmat[2][2]) - (COSmat[1][2] * COSmat[2][0]));
				detCOSc = COSmat[0][2] * ((COSmat[1][0] * COSmat[2][1]) - (COSmat[1][1] * COSmat[2][0]));
				detCOS  = detCOSa - detCOSb + detCOSc;
				if (doIshow)IJ.log("Matrix determinant: " + detCOS + " (second attempt)"+ ((detCOS >= -0.001 && detCOS <= 0.001) ? ", non invertible!":""));
			}
		}

		//3x3 matrix inversion
		A = cosy[1] - cosx[1] * cosy[0] / cosx[0];
		V = cosz[1] - cosx[1] * cosz[0] / cosx[0];
		C = cosz[2] - cosy[2] * V / A + cosx[2] * (V / A * cosy[0] / cosx[0] - cosz[0] / cosx[0]);
		q[2] = (-cosx[2] / cosx[0] - cosx[2] / A * cosx[1] / cosx[0] * cosy[0] / cosx[0] + cosy[2] / A * cosx[1] / cosx[0]) / C;
		q[1] = -q[2] * V / A - cosx[1] / (cosx[0] * A);
		q[0] = 1.0 / cosx[0] - q[1] * cosy[0] / cosx[0] - q[2] * cosz[0] / cosx[0];
		q[5] = (-cosy[2] / A + cosx[2] / A * cosy[0] / cosx[0]) / C;
		q[4] = -q[5] * V / A + 1.0 / A;
		q[3] = -q[4] * cosy[0] / cosx[0] - q[5] * cosz[0] / cosx[0];
		q[8] = 1.0 / C;
		q[7] = -q[8] * V / A;
		q[6] = -q[7] * cosy[0] / cosx[0] - q[8] * cosz[0] / cosx[0];

		if (doIshow) {
			IJ.log("\n --- Input Vector Matrix --- " + myStain + (twoDyes ? (doIcross ? "\nCh3: cross product" : "\nCh3: complementary") : ""));
			for (i = 0; i < 3; i++) {
				IJ.log("Colour[" + (i + 1) + "]:" + "  R" + (i + 1) + ": " + MODx[i] + "  G" + (i + 1) + ": " + MODy[i] + "  B" + (i + 1) + ": " + MODz[i]);
			}

			IJ.log("\nNote: When calling the exec() method of this plugin directly\nfrom another plugin use the *Input Vector Matrix* above.");

			IJ.log("\n--- Computed Vector Matrix --- " + myStain + (twoDyes ? (doIcross ? "\nC3: cross product" : "\nC3: complementary") : ""));
			for (i = 0; i < 3; i++) {
				IJ.log("Colour[" + (i + 1) + "]:" + "  R" + (i + 1) + ": " + cosx[i] + "  G" + (i + 1) + ": " + cosy[i] + "  B" + (i + 1) + ": " + cosz[i]);
			}
			IJ.log("\n--- Inverted Vector Matrix --- " + myStain + (twoDyes ? (doIcross ? "\nC3: cross product" : "\nC3: complementary") : ""));
			IJ.log("Colour[1]:  R1: " + q[0] + "  G1: " + q[1] + "  B1: " + q[2]);
			IJ.log("Colour[2]:  R2: " + q[3] + "  G2: " + q[4] + "  B2: " + q[5]);
			IJ.log("Colour[3]:  R3: " + q[6] + "  G3: " + q[7] + "  B3: " + q[8]);

			IJ.log("\n--- Java statements to include a new stain in the source code ---");
			IJ.log("\t\tif (myStain.equals(\"New_Stain\")) {");
			IJ.log("\t\t\t// This is the New_Stain's Input Vector Matrix");
			for (i=0; i<3; i++) {
				IJ.log( "\t\t\tMODx[" + i + "] = " +  MODx[i] + ";\n\t\t\tMODy[" + i + "] = " +  MODy[i] + ";\n\t\t\tMODz[" + i + "] = " +  MODz[i] + ";\n" );
			}
			IJ.log("\t\t}");
			if (myStain.equals("From ROI") || myStain.equals("User values")) {
				IJ.log("\n--- Macro example using the Input Vector Matrix determined from ROIs ---");
				IJ.log("run(\"Colour Deconvolution2\", \"vectors=[User values] output=[" + myOutput + "] simulated" + (doIcross ? " cross" : "") + " [r1]=" + MODx[0] + " [g1]=" + MODy[0] + " [b1]=" + MODz[0] + " [r2]=" + MODx[1] + " [g2]=" + MODy[1] + " [b2]=" + MODz[1] + " [r3]=" + MODx[2] + " [g3]=" + MODy[2] + " [b3]=" + MODz[2] + "\");");
			}
		}

		// initialize 3 output stacks as LUT images
		ImageStack[] outputstack = new ImageStack[3];

		// create LUTs that approximate the computed vector colours
		for (i = 0; i < 3; i++) {
			for (j = 0; j < 256; j++) {
				if (cosx[i] < 0)
					rLUT[255-j] = (byte)(255.0 + Math.floor((double)j * cosx[i] + 0.5));
				else
					rLUT[255-j] = (byte)(255.0 - Math.floor((double)j * cosx[i] + 0.5));

				if (cosy[i] < 0)
					gLUT[255-j] = (byte)(255.0 + Math.floor((double)j * cosy[i] + 0.5));
				else
					gLUT[255-j] = (byte)(255.0 - Math.floor((double)j * cosy[i] + 0.5));

				if (cosz[i] < 0)
					bLUT[255-j] = (byte)(255.0 + Math.floor((double)j * cosz[i] + 0.5));
				else
					bLUT[255-j] = (byte)(255.0 - Math.floor((double)j * cosz[i] + 0.5));
			}

			if (doILUTs && !(twoDyes && doIcross && i == 2)) {
				IndexColorModel cm = new IndexColorModel(8, 256, rLUT, gLUT, bLUT);
				outputstack[i] = new ImageStack(width, height, cm);
			}
			else
				outputstack[i] = new ImageStack(width, height);

			ColourLUT[i] = (((rLUT[0] & 0xff) << 16) + ((gLUT[0] & 0xff) << 8) + (bLUT[0] & 0xff));
		}

		ImagePlus impLegend = null, impOD0 = null, impOD1 = null, impOD2 = null;

		if (!hideLegend) {
			// create the legend
			impLegend = NewImage.createRGBImage("Colour Deconvolution", 350, 85, 1, 0);
			ImageProcessor ipL = impLegend.getProcessor();
			ipL.setFont(new Font("BOLD", Font.BOLD, 12));
			ipL.setAntialiasedText(true);
			ipL.setColor(Color.black);
			ipL.moveTo(10, 15);
			ipL.drawString("Colour deconvolution: " + myStain);

			ipL.setFont(new Font("Monospaced", Font.PLAIN, 10));
			ipL.setAntialiasedText(true);
			ipL.setColor(Color.black);
			ipL.moveTo(96, 30);
			ipL.drawString("Computed Vector Matrix");
			if (twoDyes && doIcross) ColourLUT[2]=(((127 & 0xff) << 16) + ((127 & 0xff) << 8) + (127 & 0xff));
			for (i = 0; i < 3; i++) {
				ipL.setRoi(10, 32 + i * 15, 14, 14);
				ipL.setColor(ColourLUT[i]);
				ipL.fill();
				ipL.setFont(new Font("Monospaced", Font.PLAIN, 10));
				ipL.setAntialiasedText(true);
				ipL.setColor(Color.black);
				ipL.moveTo(30, 46 + i * 15);
				ipL.drawString("Colour["+ (i + 1) + "]  R:" + String.format("% f", cosx[i]) + ", G:" + String.format("% f", cosy[i]) + ", B:" + String.format("% f", cosz[i]));
			}
		}

		//long startTime = System.currentTimeMillis();
		// translate ------------------
		int imagesize = width * height;
		int modulo = imagesize / 30;
		int R, G, B;
		double [] logPixel = new double[256];
		double output;

		//pre-compute log of pixel values and avoid log(0)
		//logPixel[0] = -Math.log(1.0 / Math.log(Double.MAX_VALUE));  // another possible way to handle it
		logPixel[0] = -Math.log(1.0/255.0);

		for(i = 1; i < 256; i++) {
			logPixel[i] = -Math.log((double) i / 255.0);
		}

		if (myOutput.equals("8bit_Transmittance")) {
			for (int imagenum = 1; imagenum <= stack.getSize(); imagenum++) {
				int[] pixels = (int[])stack.getPixels(imagenum);
				String label = stack.getSliceLabel(imagenum);
				byte[][] newpixels = new byte[3][];
				newpixels[0] = new byte[imagesize];
				newpixels[1] = new byte[imagesize];
				newpixels[2] = new byte[imagesize];

				for (j = 0; j < imagesize; j++) {
					if (j % modulo == 0) IJ.showProgress(j, imagesize);
					R = (pixels[j] & 0xff0000) >> 16;
					G = (pixels[j] & 0x00ff00) >> 8 ;
					B =  pixels[j] & 0x0000ff;

					for (i = 0; i < 3; i++) {
						// compute the transmittance
						output = 255.0 * Math.exp(-((logPixel[R] * q[i * 3]) + (logPixel[G] * q[i * 3 + 1]) + (logPixel[B] * q[i * 3 + 2])));
						output = (output > 255) ? 255: ((output < 0) ? 0: output);
						newpixels[i][j] = (byte)(0xff & (int)(Math.floor(output + 0.5)));
					}
				}
				// add new values to output images
				outputstack[0].addSlice(label, newpixels[0]);
				outputstack[1].addSlice(label, newpixels[1]);
				outputstack[2].addSlice(label, newpixels[2]);
			}
		}
		else if (myOutput.equals("32bit_Transmittance")) {
			suffix = "T";
			for (int imagenum = 1; imagenum <= stack.getSize(); imagenum++) {
				int[] pixels = (int[])stack.getPixels(imagenum);
				String label = stack.getSliceLabel(imagenum);

				float[][] newpixels = new float[3][];
				newpixels[0] = new float[imagesize];
				newpixels[1] = new float[imagesize];
				newpixels[2] = new float[imagesize];

				for (j = 0; j < imagesize; j++) {
					if (j % modulo == 0) IJ.showProgress(j, imagesize);
					R = (pixels[j] & 0xff0000) >> 16;
					G = (pixels[j] & 0x00ff00) >> 8;
					B =  pixels[j] & 0x0000ff;

					for (i = 0; i < 3; i++) {
						// compute the transmittance
						newpixels[i][j] = (float) Math.exp(-((logPixel[R] * q[i * 3]) + (logPixel[G] * q[i * 3 + 1]) + (logPixel[B] * q[i * 3 + 2])));
					}
				}
				// add new values to output images
				outputstack[0].addSlice(label,newpixels[0]);
				outputstack[1].addSlice(label,newpixels[1]);
				outputstack[2].addSlice(label,newpixels[2]);
			}
		}
		else if (myOutput.equals("32bit_Absorbance")) {
			suffix = "A";
			//logPixel[0] = -Math.log10(1.0 / Math.log(Double.MAX_VALUE));  //another possible way to handle it
			logPixel[0] = -Math.log10(1.0/255.0);

			for(i = 1; i < 256; i++) {
				logPixel[i] = -(Math.log10((double) i / 255.0)); //the definition for absorbance uses log10
			}

			for (int imagenum = 1; imagenum <= stack.getSize(); imagenum++) {
				int[] pixels = (int[])stack.getPixels(imagenum);
				String label = stack.getSliceLabel(imagenum);

				float[][] newpixels = new float[3][];
				newpixels[0] = new float[imagesize];
				newpixels[1] = new float[imagesize];
				newpixels[2] = new float[imagesize];

				for (j = 0; j < imagesize; j++) {
					if (j % modulo == 0) IJ.showProgress(j, imagesize);
					R = (pixels[j] & 0xff0000) >> 16;
					G = (pixels[j] & 0x00ff00) >> 8;
					B =  pixels[j] & 0x0000ff;

					for (i=0; i<3; i++) {
						// compute the absorbance
						newpixels[i][j] = (float) ((logPixel[R] * q[i * 3]) + (logPixel[G] * q[i * 3 + 1]) + (logPixel[B] * q[i * 3 + 2]));
					}
				}
				// add new values to output images
				outputstack[0].addSlice(label,newpixels[0]);
				outputstack[1].addSlice(label,newpixels[1]);
				outputstack[2].addSlice(label,newpixels[2]);
			}
		}
		else {
			// all the RGB options
			for (int imagenum = 1; imagenum <= stack.getSize(); imagenum++) {
				int[] pixels = (int[])stack.getPixels(imagenum);
				String label = stack.getSliceLabel(imagenum);

				double[][] newpixels = new double[3][];
				newpixels[0] = new double[imagesize];
				newpixels[1] = new double[imagesize];
				newpixels[2] = new double[imagesize];
				int rgboutput[] = new int[imagesize];

				for (j = 0; j < imagesize; j++) {
					if (j % modulo == 0) IJ.showProgress(j, imagesize);
					R = (pixels[j] & 0xff0000) >> 16;
					G = (pixels[j] & 0x00ff00) >> 8;
					B =  pixels[j] & 0x0000ff;

					for (i = 0; i < 3; i++) {
						// compute the dyes OD
						newpixels[i][j] = Math.exp(-((logPixel[R] * q[i * 3]) + (logPixel[G] * q[i * 3 + 1]) + (logPixel[B] * q[i * 3 + 2])));
					}
				}

				IJ.showProgress(1);

				if (myOutput.equals("RGB_Remove_C1")) {
						for (j = 0; j < imagesize; j++) newpixels[0][j] = 1;
				}
				else if (myOutput.equals("RGB_Remove_C2")) {
						for (j = 0; j < imagesize; j++) newpixels[1][j] = 1;
				}
				else if (myOutput.equals("RGB_Remove_C3")) {
					for (j = 0; j < imagesize; j++) newpixels[2][j] = 1;
				}
				else if (myOutput.equals("RGB_Keep_C1")) {
					for (j = 0; j < imagesize; j++) {
						newpixels[1][j] = 1;
						newpixels[2][j] = 1;
					}
				}
				else if (myOutput.equals("RGB_Keep_C2")) {
					for (j = 0; j < imagesize; j++) {
						newpixels[0][j] = 1;
						newpixels[2][j] = 1;
					}
				}
				else if (myOutput.equals("RGB_Keep_C3")) {
					for (j = 0; j < imagesize; j++) {
						newpixels[0][j] = 1;
						newpixels[1][j] = 1;
					}
				}

				for (j = 0; j < imagesize; j++) {
					if (j % modulo == 0) IJ.showProgress(j, imagesize);

					//compute the image intensity
					R = (int)(255.0 * Math.exp((Math.log(newpixels[0][j]) * cosx[0]) + (Math.log(newpixels[1][j]) * cosx[1]) + (Math.log(newpixels[2][j]) * cosx[2])));
					G = (int)(255.0 * Math.exp((Math.log(newpixels[0][j]) * cosy[0]) + (Math.log(newpixels[1][j]) * cosy[1]) + (Math.log(newpixels[2][j]) * cosy[2])));
					B = (int)(255.0 * Math.exp((Math.log(newpixels[0][j]) * cosz[0]) + (Math.log(newpixels[1][j]) * cosz[1]) + (Math.log(newpixels[2][j]) * cosz[2])));

					R = (R > 255) ? 255: ((R < 0) ? 0: R);
					G = (G > 255) ? 255: ((G < 0) ? 0: G);
					B = (B > 255) ? 255: ((B < 0) ? 0: B);
					rgboutput[j] = ((R & 0xff) << 16) + ((G & 0xff) << 8) + (B & 0xff);
				}
				outputstack[0].addSlice(label, rgboutput);
			}
		}
		IJ.showProgress(1);
		IJ.showStatus("Done.");
		//IJ.log( "Time used = " + (System.currentTimeMillis() - startTime) / 1000.0 );

		if (myOutput.equals("8bit_Transmittance") || myOutput.equals("32bit_Transmittance") || myOutput.equals("32bit_Absorbance")) {
			impOD0 = new ImagePlus(title+"-(Colour_1)" + suffix, outputstack[0]);
			impOD1 = new ImagePlus(title+"-(Colour_2)" + suffix, outputstack[1]);
			impOD2 = new ImagePlus(title+"-(Colour_3)" + suffix, outputstack[2]);
			return new Object[] {impLegend, impOD0, impOD1, impOD2};
		}
		else{
			impOD0 = new ImagePlus(title+"-"+myOutput, outputstack[0]);
			return new Object[] {impLegend, impOD0};
		}
	}


	void getmeanRGBODfromROI(int i, double [] rgbOD, ImagePlus imp) {
		//get a ROI and its mean optical density. GL
		int [] xyzf = new int [4]; //[0]=x, [1]=y, [2]=z, [3]=flags
		int x1, y1, x2, y2, h = 0, w = 0, px = 0, py = 0, j, x, y, p;
		ImageProcessor ip = imp.getProcessor();
		int mw = ip.getWidth() - 1;
		int mh = ip.getHeight() - 1;

		double [] logPixel = new double[256];
		//logPixel[0] = -Math.log(1.0 / Math.log(Double.MAX_VALUE));
		logPixel[0] = -Math.log(1.0/255.0);

		for(j = 1; j < 256; j++) {
			logPixel[j] = -Math.log((double) j / 255.0);
		}

		IJ.showMessage("Select ROI for Colour_"+(i+1)+".\n \n(Right-click to end)");
		getCursorLoc(xyzf, imp);
		while ((xyzf[3] & 4) != 0) {  //trap until right button is released
			getCursorLoc(xyzf, imp);
			IJ.wait(20);
		}

		while (((xyzf[3] & 16) == 0) && ((xyzf[3] & 4) == 0)) { //trap until button is pressed
			getCursorLoc(xyzf, imp);
			IJ.wait(20);
		}

		rgbOD[0] = 0;
		rgbOD[1] = 0;
		rgbOD[2] = 0;

		if ((xyzf[3] & 4) == 0) {// right was not pressed, but left (ROI) was
			x1 = xyzf[0];
			y1 = xyzf[1];
			//IJ.log("first point x:" + x1 + "  y:" + y1);
			x2 = x1;
			y2 = y1;
			while ((xyzf[3] & 4) == 0) {//until right button is pressed
				getCursorLoc(xyzf, imp);
				if (xyzf[0] != x2 || xyzf[1] != y2) {
					if (xyzf[0] < 0) xyzf[0] = 0;
					if (xyzf[1] < 0) xyzf[1] = 0;
					if (xyzf[0] > mw) xyzf[0] = mw;
					if (xyzf[1] > mh) xyzf[1] = mh;
					x2 = xyzf[0];
					y2 = xyzf[1];
					w = x2 - x1 + 1;
					h = y2 - y1 + 1;

					if (x2 < x1) {
						px = x2;
						w = (x1 - x2) + 1;
					}
					else
						px = x1;

					if (y2 < y1) {
						py = y2;
						h = (y1 - y2) + 1;
					}
					else
						py = y1;

					IJ.makeRectangle(px, py, w, h);
					//IJ.log("Box x:" + x2 +"  y:" + y2+" w:"+w+" h:"+h);
				}
				IJ.wait(20);
			}

			while ((xyzf[3] & 16) != 0) { //trap until left released
				getCursorLoc(xyzf, imp);
				IJ.wait(20);
			}

			for (x = px; x < (px + w); x++) {
				for(y = py; y < (py + h); y++) {
					p = ip.getPixel(x, y);
					// accumulate absorbance
					rgbOD[0] = rgbOD[0] + logPixel[(p & 0xff0000) >> 16];
					rgbOD[1] = rgbOD[1] + logPixel[(p & 0x00ff00) >> 8 ];
					rgbOD[2] = rgbOD[2] + logPixel[(p & 0x0000ff)      ];
				}
			}
			// average absorbance
			rgbOD[0] = rgbOD[0] / (w*h);
			rgbOD[1] = rgbOD[1] / (w*h);
			rgbOD[2] = rgbOD[2] / (w*h);
		}
		IJ.run(imp, "Select None", "");
	}


	void getCursorLoc(int [] xyzf, ImagePlus imp) {
		ImageWindow win = imp.getWindow();
		ImageCanvas ic = win.getCanvas();
		Point p = ic.getCursorLoc();
		xyzf[0] = p.x;
		xyzf[1] = p.y;
		xyzf[2] = imp.getCurrentSlice() - 1;
		xyzf[3] = ic.getModifiers();
	}
}

